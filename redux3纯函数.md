#纯函数Pure Function

我们接下来会继续优化我们的`createStore`的模式，让它使我们的应用程序获得更好的性能。

我们先介绍一下 一个函数式编程里面非常重要的概念-----纯函数pure function

简单来说，**一个函数的返回结果只依赖于它的参数，并且在执行过程里面没有副作用，我们就把这个函数叫做纯函数**。这么说肯定比较抽象，我们把它掰开来看：

1.函数的返回结果只依赖于它的参数。
2.函数执行过程里面没有副作用。

##函数的返回结果只依赖于它的参数

    const a = 1
    const foo = (b)=> a+b
    
    foo(2)// 3

`foo`函数不是一个纯函数，因为它返回的结果依赖于外部变量`a`，我们在不知道`a`的值的情况下，并不能保证`foo(2)`的返回值是3.虽然foo函数的代码实现并没有变化，传入的参数也没有变化，但它的返回值确实不可预料的。因为a可能发生了变化。

    const a = 1
    const foo = (x, b)=> x + b
    
    foo(1, 2)// 3

现在foo的返回结果只依赖于它的参数x和b，foo(1,2)永远是3。今天是3，明天是3，永远都是3.只要foo代码不变，你传染入的参数是确定的，那么foo（1，2）的值永远是可预料的。

这就是纯函数的第一个条件： **一个函数的返回结果只依赖于它的参数**

##函数执行过程没有副作用

一个函数执行过程对产生了**外部可观察的变化**那么就说这个函数时有副作用的。

我们修改一下foo：

    const a = 1 
    const foo = (obj, b)=>{
    	return obj.x + b
    }
    
    const counter = {x:1}
    foo(counter, 2)//3
    counter.x//1

我们把原来的x换成了obj，我现在可以往里面传一个对象进行计算，计算的过程里面并不会对传入的对象进行修改，计算前后的counter不会发生任何变化，计算前是1，计算后也是1，它现在是纯的。

但是你再函数内部构建的变量，然后进行数据的修改不是副作用：

const foo = (b) => {
	const obj = { x:1 }
	obj.x = 2
	return obj.x + b
}

虽然foo函数内部修改了obj，但是obj是内部变量，外部程序根本观察不到，修改obj并不会产生外部可观察的变化，这个函数时没有副作用的，因此它是一个纯函数。

除了修改外部的变量，一个函数在执行过程中还有狠毒哦方式产生**外部可观察的变化**，比如说调用DOM API 修改页面，或者你发送了Ajax请求，还有调用window.reload刷新浏览器，甚至是`console.log`往控制台打印数据也是副作用。

纯函数很严格，也就是说你几乎除了计算数据以外什么都不能干，计算的时候还不能依赖除了函数参数以外的数据。

##总结

一个函数的返回结果只依赖于它的参数，并且在执行过程里面没有副作用，我们就把这个函数叫做纯函数。

为什么要煞费苦心地构建纯函数？因为纯函数非常“靠谱”，执行一个纯函数你不用担心它会干什么坏事，它不会产生不可预料的行为，也不会对外部产生影响。不管何时何地，你给它什么它就会乖乖地吐出什么。如果你的应用程序大多靠纯函数组成，那么你的程序测试，调试起来会非常方便。